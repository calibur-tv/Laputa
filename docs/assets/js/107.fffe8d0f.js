(window.webpackJsonp=window.webpackJsonp||[]).push([[107],{348:function(a,s,e){"use strict";e.r(s);var t=e(0),r=Object(t.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var a=this,s=a.$createElement,e=a._self._c||s;return e("div",{staticClass:"content"},[e("h1",{attrs:{id:"upgrading-from-php-parser-1-x-to-2-0"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#upgrading-from-php-parser-1-x-to-2-0","aria-hidden":"true"}},[a._v("#")]),a._v(" Upgrading from PHP-Parser 1.x to 2.0")]),a._v(" "),e("h3",{attrs:{id:"php-version-requirements"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#php-version-requirements","aria-hidden":"true"}},[a._v("#")]),a._v(" PHP version requirements")]),a._v(" "),e("p",[a._v("PHP-Parser now requires PHP 5.4 or newer to run. It is however still possible to "),e("em",[a._v("parse")]),a._v(" PHP 5.2 and\nPHP 5.3 source code, while running on a newer version.")]),a._v(" "),e("h3",{attrs:{id:"creating-a-parser-instance"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#creating-a-parser-instance","aria-hidden":"true"}},[a._v("#")]),a._v(" Creating a parser instance")]),a._v(" "),e("p",[a._v("Parser instances should now be created through the "),e("code",[a._v("ParserFactory")]),a._v(". Old direct instantiation code\nwill not work, because the parser class was renamed.")]),a._v(" "),e("p",[a._v("Old:")]),a._v(" "),e("div",{staticClass:"language-php extra-class"},[e("pre",{pre:!0,attrs:{class:"language-php"}},[e("code",[e("span",{attrs:{class:"token keyword"}},[a._v("use")]),a._v(" "),e("span",{attrs:{class:"token package"}},[a._v("PhpParser"),e("span",{attrs:{class:"token punctuation"}},[a._v("\\")]),a._v("Parser")]),e("span",{attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" PhpParser\\"),e("span",{attrs:{class:"token package"}},[a._v("Lexer")]),e("span",{attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),e("span",{attrs:{class:"token variable"}},[a._v("$parser")]),a._v(" "),e("span",{attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),e("span",{attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),e("span",{attrs:{class:"token class-name"}},[a._v("Parser")]),e("span",{attrs:{class:"token punctuation"}},[a._v("(")]),e("span",{attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),e("span",{attrs:{class:"token class-name"}},[a._v("Lexer"),e("span",{attrs:{class:"token punctuation"}},[a._v("\\")]),a._v("Emulative")]),e("span",{attrs:{class:"token punctuation"}},[a._v(")")]),e("span",{attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])])]),e("p",[a._v("New:")]),a._v(" "),e("div",{staticClass:"language-php extra-class"},[e("pre",{pre:!0,attrs:{class:"language-php"}},[e("code",[e("span",{attrs:{class:"token keyword"}},[a._v("use")]),a._v(" "),e("span",{attrs:{class:"token package"}},[a._v("PhpParser"),e("span",{attrs:{class:"token punctuation"}},[a._v("\\")]),a._v("ParserFactory")]),e("span",{attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),e("span",{attrs:{class:"token variable"}},[a._v("$parser")]),a._v(" "),e("span",{attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),e("span",{attrs:{class:"token punctuation"}},[a._v("(")]),e("span",{attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),e("span",{attrs:{class:"token class-name"}},[a._v("ParserFactory")]),e("span",{attrs:{class:"token punctuation"}},[a._v(")")]),e("span",{attrs:{class:"token operator"}},[a._v("-")]),e("span",{attrs:{class:"token operator"}},[a._v(">")]),e("span",{attrs:{class:"token function"}},[a._v("create")]),e("span",{attrs:{class:"token punctuation"}},[a._v("(")]),a._v("ParserFactory"),e("span",{attrs:{class:"token punctuation"}},[a._v(":")]),e("span",{attrs:{class:"token punctuation"}},[a._v(":")]),e("span",{attrs:{class:"token constant"}},[a._v("PREFER_PHP7")]),e("span",{attrs:{class:"token punctuation"}},[a._v(")")]),e("span",{attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])])]),e("p",[a._v("The first argument to "),e("code",[a._v("ParserFactory")]),a._v(" determines how different PHP versions are handled. The\npossible values are:")]),a._v(" "),e("ul",[e("li",[e("code",[a._v("ParserFactory::PREFER_PHP7")]),a._v(": Try to parse code as PHP 7. If this fails, try to parse it as PHP 5.")]),a._v(" "),e("li",[e("code",[a._v("ParserFactory::PREFER_PHP5")]),a._v(": Try to parse code as PHP 5. If this fails, try to parse it as PHP 7.")]),a._v(" "),e("li",[e("code",[a._v("ParserFactory::ONLY_PHP7")]),a._v(": Parse code as PHP 7.")]),a._v(" "),e("li",[e("code",[a._v("ParserFactory::ONLY_PHP5")]),a._v(": Parse code as PHP 5.")])]),a._v(" "),e("p",[a._v("For most practical purposes the difference between "),e("code",[a._v("PREFER_PHP7")]),a._v(" and "),e("code",[a._v("PREFER_PHP5")]),a._v(" is mainly whether\na scalar type hint like "),e("code",[a._v("string")]),a._v(" will be stored as "),e("code",[a._v("'string'")]),a._v(" (PHP 7) or as "),e("code",[a._v("new Name('string')")]),a._v("\n(PHP 5).")]),a._v(" "),e("p",[a._v("To use a custom lexer, pass it as the second argument to the "),e("code",[a._v("create()")]),a._v(" method:")]),a._v(" "),e("div",{staticClass:"language-php extra-class"},[e("pre",{pre:!0,attrs:{class:"language-php"}},[e("code",[e("span",{attrs:{class:"token keyword"}},[a._v("use")]),a._v(" "),e("span",{attrs:{class:"token package"}},[a._v("PhpParser"),e("span",{attrs:{class:"token punctuation"}},[a._v("\\")]),a._v("ParserFactory")]),e("span",{attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),e("span",{attrs:{class:"token variable"}},[a._v("$lexer")]),a._v(" "),e("span",{attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),e("span",{attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),e("span",{attrs:{class:"token class-name"}},[a._v("MyLexer")]),e("span",{attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),e("span",{attrs:{class:"token variable"}},[a._v("$parser")]),a._v(" "),e("span",{attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),e("span",{attrs:{class:"token punctuation"}},[a._v("(")]),e("span",{attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),e("span",{attrs:{class:"token class-name"}},[a._v("ParserFactory")]),e("span",{attrs:{class:"token punctuation"}},[a._v(")")]),e("span",{attrs:{class:"token operator"}},[a._v("-")]),e("span",{attrs:{class:"token operator"}},[a._v(">")]),e("span",{attrs:{class:"token function"}},[a._v("create")]),e("span",{attrs:{class:"token punctuation"}},[a._v("(")]),a._v("ParserFactory"),e("span",{attrs:{class:"token punctuation"}},[a._v(":")]),e("span",{attrs:{class:"token punctuation"}},[a._v(":")]),e("span",{attrs:{class:"token constant"}},[a._v("PREFER_PHP7")]),e("span",{attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),e("span",{attrs:{class:"token variable"}},[a._v("$lexer")]),e("span",{attrs:{class:"token punctuation"}},[a._v(")")]),e("span",{attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])])]),e("h3",{attrs:{id:"rename-of-the-phpparser-parser-class"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#rename-of-the-phpparser-parser-class","aria-hidden":"true"}},[a._v("#")]),a._v(" Rename of the "),e("code",[a._v("PhpParser\\Parser")]),a._v(" class")]),a._v(" "),e("p",[e("code",[a._v("PhpParser\\Parser")]),a._v(" is now an interface, which is implemented by "),e("code",[a._v("Parser\\Php5")]),a._v(", "),e("code",[a._v("Parser\\Php7")]),a._v(" and\n"),e("code",[a._v("Parser\\Multiple")]),a._v(". Parser tokens are now defined in "),e("code",[a._v("Parser\\Tokens")]),a._v(". If you use the "),e("code",[a._v("ParserFactory")]),a._v("\ndescribed above to create your parser instance, these changes should have no further impact on you.")]),a._v(" "),e("h3",{attrs:{id:"removal-of-legacy-aliases"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#removal-of-legacy-aliases","aria-hidden":"true"}},[a._v("#")]),a._v(" Removal of legacy aliases")]),a._v(" "),e("p",[a._v("All legacy aliases for classes have been removed. This includes the old non-namespaced "),e("code",[a._v("PHPParser_")]),a._v("\nclasses, as well as the classes that had to be renamed for PHP 7 support.")]),a._v(" "),e("h3",{attrs:{id:"deprecations"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#deprecations","aria-hidden":"true"}},[a._v("#")]),a._v(" Deprecations")]),a._v(" "),e("p",[a._v("The "),e("code",[a._v("set()")]),a._v(", "),e("code",[a._v("setFirst()")]),a._v(", "),e("code",[a._v("append()")]),a._v(" and "),e("code",[a._v("prepend()")]),a._v(" methods of the "),e("code",[a._v("Node\\Name")]),a._v(" class have been\ndeprecated. Instead "),e("code",[a._v("Name::concat()")]),a._v(" and "),e("code",[a._v("Name->slice()")]),a._v(" should be used.")]),a._v(" "),e("h3",{attrs:{id:"miscellaneous"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#miscellaneous","aria-hidden":"true"}},[a._v("#")]),a._v(" Miscellaneous")]),a._v(" "),e("ul",[e("li",[a._v("The "),e("code",[a._v("NodeTraverser")]),a._v(" no longer clones nodes by default. If you want to restore the old behavior,\npass "),e("code",[a._v("true")]),a._v(" to the constructor.")]),a._v(" "),e("li",[a._v("The legacy node format has been removed. If you use custom nodes, they are now expected to\nimplement a "),e("code",[a._v("getSubNodeNames()")]),a._v(" method.")]),a._v(" "),e("li",[a._v("The default value for "),e("code",[a._v("Scalar")]),a._v(" node constructors was removed. This means that something like\n"),e("code",[a._v("new LNumber()")]),a._v(" should be replaced by "),e("code",[a._v("new LNumber(0)")]),a._v(".")]),a._v(" "),e("li",[a._v("String parts of encapsed strings are now represented using "),e("code",[a._v("Scalar\\EncapsStringPart")]),a._v(" nodes, while\npreviously raw strings were used. This affects the "),e("code",[a._v("parts")]),a._v(" child of "),e("code",[a._v("Scalar\\Encaps")]),a._v(" and\n"),e("code",[a._v("Expr\\ShellExec")]),a._v(".")])])])}],!1,null,null,null);s.default=r.exports}}]);